using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using UnityEngine;
using static Settings;

/*
 *  The singleton settings instance which will be present in all scenes
 *  This contains the pairing of every setting and its respective value
 *  that can be changed during the game and initalized through the inspector
 *  
 *  Go through the dictionary to set a value
 */
public class SettingsInstance : MonoBehaviour
{
    // The settings instance
    public static SettingsInstance Instance { get; private set; }

    [Header("Controls")]
    // The set of KeyCode pairings
    public KeyCodeValue[] controlsValues =
    {
        new KeyCodeValue { key = Controls.Interact, value = KeyCode.F },
        new KeyCodeValue { key = Controls.MenuTransition, value = KeyCode.Escape },
        new KeyCodeValue { key = Controls.LeftClick, value = KeyCode.Mouse0 },
        new KeyCodeValue { key = Controls.RightClick, value = KeyCode.Mouse1 },
        new KeyCodeValue { key = Controls.DialogSkip, value = KeyCode.Return },
        new KeyCodeValue { key = Controls.UIExit, value = KeyCode.Backspace },
        new KeyCodeValue { key = Controls.MoveUp, value = KeyCode.W },
        new KeyCodeValue { key = Controls.MoveDown, value = KeyCode.S },
        new KeyCodeValue { key = Controls.MoveLeft, value = KeyCode.A },
        new KeyCodeValue { key = Controls.MoveRight, value = KeyCode.D }
    };

    [Header("Floats")]
    // The set of float value pairings
    public FloatValue[] floatValues =
    {
        new FloatValue { key = FloatValues.DialogDisplayYLocation, value = -3.0f },
        new FloatValue { key = FloatValues.PlayerInteractDistance, value = 1.0f },
        new FloatValue { key = FloatValues.DialogCharactersPerSecond, value = 32f },
        new FloatValue { key = FloatValues.DialogCompletionWaitForCloseSeconds, value = 5f }
    };

    [Header("Animations")]
    // The set of prefab animation pairings
    public PrefabAnimationValue[] prefabAnimValues = 
    { 
        new PrefabAnimationValue { key = PrefabAnimations.NullAnim, value = AnimationSpriteClass.NULL_STRUCT }
    };

    [Header("Prefab Objects")]
    // The set of prefab object pairings
    public PrefabObjectValue[] prefabObjectValues = { };

    [Header("Matereials")]
    //The set of prefab material pairings
    public PrefabMaterialValue[] prefabMaterialValues = { };

    [Header("Other")]
    public bool canLogWarnings = false;
    public bool canInput = true;

    //Dictionaries generated by the value sets
    public Dictionary<Controls, KeyCodeValue> controlsPairings = new Dictionary<Controls, KeyCodeValue>();
    public Dictionary<FloatValues, FloatValue> floatPairings = new Dictionary<FloatValues, FloatValue>();
    public Dictionary<PrefabAnimations, PrefabAnimationValue> animPairings = new Dictionary<PrefabAnimations, PrefabAnimationValue>();
    public Dictionary<PrefabObjects, PrefabObjectValue> objectPairings = new Dictionary<PrefabObjects, PrefabObjectValue>();
    public Dictionary<PrefabMaterials, PrefabMaterialValue> materialPairings = new Dictionary<PrefabMaterials, PrefabMaterialValue>();

    void Awake()
    {
        Instance = this;
        DontDestroyOnLoad(gameObject);

        //Set up dicitonaries
        foreach (KeyCodeValue v in controlsValues){controlsPairings[v.key] = v;}
        foreach (FloatValue v in floatValues) { floatPairings[v.key] = v; }
        foreach (PrefabAnimationValue v in prefabAnimValues) { animPairings[v.key] = v; }
        foreach (PrefabObjectValue v in prefabObjectValues) { objectPairings[v.key] = v; }
        foreach (PrefabMaterialValue v in prefabMaterialValues) { materialPairings[v.key] = v; }
    }

    // Key value parings for each setting type
    [System.Serializable] public struct KeyCodeValue { public Controls key; public KeyCode value; }
    [System.Serializable] public struct FloatValue { public FloatValues key; public float value; }
    [System.Serializable] public struct PrefabAnimationValue { public PrefabAnimations key; public AnimationSpriteClass.AnimationStruct value; }
    [System.Serializable] public struct PrefabObjectValue { public PrefabObjects key; public GameObject value; }
    [System.Serializable] public struct PrefabMaterialValue { public PrefabMaterials key; public Material value; }
}

/*
 * The accessor for the settings.
 * All code should access the respective setting through the enum
 */
public static class Settings
{
    // Key Code controls
    public enum Controls
    {
        Interact, LeftClick, MenuTransition, RightClick, DialogSkip, UIExit, MoveLeft, MoveRight, MoveUp, MoveDown
    }

    // Float values
    public enum FloatValues
    {
        PlayerInteractDistance, DialogDisplayYLocation, DialogCharactersPerSecond, DialogCompletionWaitForCloseSeconds
    }

    // Prefab animations
    public enum PrefabAnimations
    {
        BoeBon, NullAnim
    }
    // Prefab objects
    public enum PrefabObjects
    {
        DialogDisplay
    }

    // Prefab Materials
    public enum PrefabMaterials
    {
        Null, Clickable, Dragable, Interactable
    }

    //Returns the KeyCode associated with the Control
    public static KeyCode GetKeyCode(this Controls control)
    {
        RequireSettingsInstance();
        return SettingsInstance.Instance.controlsPairings[control].value;
    }

    // Returns Input.GetKey evaluated on the associatied KeyCode
    // If forceGetInput, returns if the key is pressed independent if Input is enabled
    public static bool GetKey(this Controls control, bool forceGetInput = false)
    {
        RequireSettingsInstance();
        return Input.GetKey(control.GetKeyCode()) && (IsInputEnabled() || forceGetInput);
    }

    // Returns Input.GetKeyDown evaluated on the associatied KeyCode
    // If forceGetInput, returns if the key is pressed independent if Input is enabled
    public static bool GetKeyDown(this Controls control, bool forceGetInput = false)
    {
        RequireSettingsInstance();
        return Input.GetKeyDown(control.GetKeyCode()) && (IsInputEnabled() || forceGetInput);
    }

    // Returns Input.GetKeyUp evaluated on the associatied KeyCode
    // If forceGetInput, returns if the key is pressed independent if Input is enabled
    public static bool GetKeyUp(this Controls control, bool forceGetInput = false)
    {
        RequireSettingsInstance();
        return Input.GetKeyUp(control.GetKeyCode()) && (IsInputEnabled() || forceGetInput);
    }

    //Returns the float associated with the FloatValue
    public static float Get(this FloatValues value)
    {
        RequireSettingsInstance();
        return SettingsInstance.Instance.floatPairings[value].value;
    }

    //Returns the associated prefab object
    public static GameObject Get(this PrefabObjects obj)
    {
        RequireSettingsInstance();
        return SettingsInstance.Instance.objectPairings[obj].value;
    }

    //Returns the associated prefab material
    public static Material Get(this PrefabMaterials obj)
    {
        RequireSettingsInstance();
        return SettingsInstance.Instance.materialPairings[obj].value;
    }

    //Returns the associated animation 
    public static AnimationSpriteClass.AnimationStruct Get(this PrefabAnimations obj)
    {
        RequireSettingsInstance();
        return SettingsInstance.Instance.animPairings[obj].value;
    }

    private static void RequireSettingsInstance()
    {
        if(SettingsInstance.Instance == null)
        {
            // This can occur if the object calling is loaded before settings
            // And this is required in the load method
            throw new NullReferenceException("The Settings instance is not in the scene");
        }
    }

    // Display Warning
    public static void DisplayWarning(string warning, GameObject fromObject)
    {
        RequireSettingsInstance();
        if (SettingsInstance.Instance.canLogWarnings)
        {
            Debug.LogWarning(warning + " | Generated by gameObject : " + fromObject?.name);
        }
    } 

    // Displays Error
    public static void DisplayError(string error, GameObject fromObject)
    {
        RequireSettingsInstance();
        Debug.LogError(error + " | Generated by gameObject : " + fromObject?.name);
    }


    // Disables the ability for input to return true through settings methods
    public static void DisableInput()
    {
        SettingsInstance.Instance.canInput = false;
    }

    // Enables the ability for input to return true through settings methods
    public static void EnableInput()
    {
        SettingsInstance.Instance.canInput = true;
    }

    public static bool IsInputEnabled()
    {
        return SettingsInstance.Instance.canInput;
    }

}
